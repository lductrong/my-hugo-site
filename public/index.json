[
{
	"uri": "//localhost:1313/",
	"title": "Building a Serverless Text-to-Speech Application with Amazon Polly",
	"tags": [],
	"description": "",
	"content": "Building a Serverless Text-to-Speech Application with Amazon Polly Overview Text-to-speech (TTS) conversion is a complex technology that requires in-depth research. It’s possible for some words to be read out without any meaning at all. Factors contributing to these errors in TTS applications include: homographs (words that are spelled the same but pronounced differently), text normalization, phonetic conversion, proper names, slang, and abbreviations.\nAmazon Polly provides the ability to overcome these issues, allowing us to focus on building applications that utilize TTS technology without worrying about algorithmic problems.\nIntroduction to Amazon Polly Amazon Polly is Amazon Web Services\u0026rsquo; (AWS) text-to-speech (TTS) service. Polly uses deep learning technology to convert text into natural-sounding speech in multiple languages, making it easy to integrate into applications for creating high-quality audio content.\nKey Features of Amazon Polly:\nNatural-sounding Voices: Polly supports dozens of realistic voices across more than 20 languages. Quick Response Time: The service provides real-time response times, suitable for applications like virtual assistants and chatbots. Easy Integration: Polly is easy to integrate via API. SSML Support: Polly supports Speech Synthesis Markup Language (SSML), allowing customization of voice with elements like intonation, speed, and pronunciation. Cost-effective: There are no additional charges for using converted audio. Storage and Playback Capability: Polly allows the storage and playback of audio files for use without a network connection. Workshop Objectives The Text-to-Speech (TTS) application diversifies information accessibility, especially for visually impaired individuals. It enhances user experience in virtual assistant systems, chatbots, or serves entertainment activities like listening to books, newspapers, and stories.\nIn this workshop, you will be introduced to how to build a serverless Text-to-Speech application with Amazon Polly, and how to integrate Amazon Polly into your application to convert text into natural-sounding speech.\n"
},
{
	"uri": "//localhost:1313/3-target-group/3.1/",
	"title": "Create DynamoDB Table",
	"tags": [],
	"description": "",
	"content": "In this task, we will create a table in DynamoDB to store information about posts, including the text content and the corresponding MP3 file URL. We will create a \u0026ldquo;posts\u0026rdquo; table with a primary key (id) that is a string generated by the \u0026ldquo;New Post\u0026rdquo; Lambda function when a new post is inserted into the database.\nThe steps are as follows: Step 1. Navigate to the DynamoDB service page.\nStep 2. Select Create table.\nStep 3. Set up the table as follows:\nTable name: posts\nPartition key: id\nTable settings: Select the default Default settings.\nStep 4. Click Create table to create the table.\n"
},
{
	"uri": "//localhost:1313/1-prerequisite/",
	"title": "Workshop Outline",
	"tags": [],
	"description": "",
	"content": "Objectives After completing the workshop, you will be able to: Create an Amazon DynamoDB table to store data Create a RESTful API with Amazon API Gateway Create AWS Lambda functions triggered by API Gateway Connect AWS Lambda functions with Amazon Simple Notification Service (SNS) Use Amazon Polly to synthesize speech in various languages and tones Workshop Environment Since we are building a serverless application, you do not need to work with servers—no need to provision resources, patch, or scale. AWS Cloud will handle all of this automatically, allowing you to focus on your application.\nThis application provides two main methods—one for sending information about a new post (which will be converted to an MP3 file) and one for retrieving information about an existing post (including the link to the MP3 file stored in an Amazon S3 bucket). Both of these methods are implemented as RESTful web services through Amazon API Gateway.\nWhen sending information about a new post: Information is sent via the RESTful web service provided by Amazon API Gateway. This service is called from a static website hosted on Amazon S3. Amazon API Gateway triggers an AWS Lambda function named \u0026ldquo;New Post,\u0026rdquo; which is responsible for initiating the MP3 file creation process. This Lambda function inserts the post information into an Amazon DynamoDB table, where information about all posts is stored. To handle the entire process asynchronously, the application uses Amazon Simple Notification Service (SNS) to decouple the process of receiving new post information from the process of converting the post to audio. Another Lambda function named \u0026ldquo;Convert to Audio\u0026rdquo; is subscribed to this SNS topic and will be triggered whenever there is a new notification (indicating a new post needs to be converted to an audio file). The \u0026ldquo;Convert to Audio\u0026rdquo; Lambda function uses Amazon Polly to convert the text into an audio file in the specified language (which must match the language of the text). The new MP3 file is stored in an S3 bucket. The post information is updated in the DynamoDB table, including the URL of the audio file stored in S3. When retrieving information about a post: The RESTful web service implemented through Amazon API Gateway provides a method to retrieve post information. This method contains the text of the post and the link to the S3 bucket where the MP3 file is stored. This web service is also called from a static website hosted on Amazon S3. Amazon API Gateway calls the Get Post Lambda, which implements the logic to retrieve the post data. The Get Post Lambda function fetches the post information (including the link to Amazon S3) from the DynamoDB table and returns that information. "
},
{
	"uri": "//localhost:1313/3-target-group/3.2/",
	"title": "Creating an Amazon S3 Bucket",
	"tags": [],
	"description": "",
	"content": "In this task, we will create an Amazon S3 bucket to store all the audio files that will be generated by the application later. S3 is an ideal choice due to its security, scalability, and high durability (99.999999999%) along with high availability (99.99%).\nSteps to Follow: Step 1. Navigate to the AWS Management Console and search for S3.\nStep 2. On the S3 service page, select Create bucket.\nStep 3. Configure the Bucket.\nBucket name: Enter a unique name; here I named it audioposts-19012003.\nPlease note down the bucket name for future use.\nObject Ownership: Select “ACLs enabled.”\nBlock Public Access settings:\nUncheck “Block all public access.” Then uncheck all other options. Select the box “I acknowledge that the current settings might result in this bucket and the objects within becoming public.”\nStep 4. Select Create bucket to complete the bucket creation.\nBecause each Amazon S3 bucket must have a globally unique name across all AWS accounts, if the name is already taken, AWS will display the error “Bucket with the same name already exists” and automatically take you back to the bucket name field to choose a different name. Try changing the numbers until the name is unique.\nConversely, you will receive a notification when the S3 bucket is created successfully.\n"
},
{
	"uri": "//localhost:1313/2-launch-template/",
	"title": "Setting Up the Environment",
	"tags": [],
	"description": "",
	"content": "Initializing a CloudFormation Stack We will use an AWS CloudFormation template to set up the resources needed for the workshop in the AWS Region of your choice. This is crucial as the subsequent instructions will depend on these resources. This CloudFormation template will provide the following resources:\nIAM Role Amazon DynamoDB Table AWS Step Functions State Machine The steps are as follows:\nStep 1. Download the CloudFormation template (YAML file) and save it in a separate folder on your computer: Download here.\nStep 2. Open the AWS CloudFormation Console.\nStep 3. Choose Create stack.\nStep 4. Create the stack.\nUnder Prepare template, choose Choose an existing template. Under Template source, select Upload a template file. Choose the template file you just downloaded and then select Next. Step 5. Name your stack.\nHere, I named it TTS-serverless. Select Next.\nStep 6. Leave the stack configurations at default.\nIn the Capabilities section, allow AWS CloudFormation to create IAM resources.\nSelect Submit to deploy the template.\n"
},
{
	"uri": "//localhost:1313/3-target-group/3.3/",
	"title": "Creating an SNS Topic",
	"tags": [],
	"description": "",
	"content": "In this task, we will create an SNS topic to facilitate communication between Lambda functions. Setting up the SNS topic is essential because the process of converting a post (in text format) to an audio file is divided into two AWS Lambda functions. This is due to several reasons:\nAsynchronous operation and quick response for users:\nWhen a new post is submitted, we will immediately receive the post ID in DynamoDB even if the conversion to an audio file is not yet complete. This enhances the user experience, especially for larger posts, as users do not have to wait long.\nResource optimization and scalability:\nSeparating the two processes allows for optimized resource usage and scaling of the system when needed. For example, the first Lambda function only needs to perform lightweight operations such as logging the post and saving it to DynamoDB, while the second function will handle the more complex conversion with Amazon Polly.\nFlexibility:\nBy separating the process of creating posts and converting audio, we create a more flexible and maintainable system.\nSteps to Follow: Step 1. Navigate to the AWS Management Console and search for SNS.\nStep 2. On the Amazon Simple Notification Service page, select Topics, then choose Create topic.\nStep 3. Configure the topic.\nType: Select Standard. Name: Enter new_posts. Display name: Enter New Posts. Step 4. At the bottom of the page, select Create topic.\nStep 5. Save the ARN of the topic.\nAfter creating, you will see the ARN of the topic (Amazon Resource Name). Please note down this ARN for use in configuring the Lambda functions.\n"
},
{
	"uri": "//localhost:1313/3-target-group/",
	"title": "Task List",
	"tags": [],
	"description": "",
	"content": "Here is a list of 9 tasks that need to be completed in this workshop:\nCreate a DynamoDB table Create an Amazon S3 bucket Create an SNS topic Create a Lambda function for new posts Create a Lambda function for audio conversion Test the functions Create a Lambda function to retrieve posts Expose the Lambda function as a RESTful web service Create a serverless user interface "
},
{
	"uri": "//localhost:1313/3-target-group/3.4/",
	"title": "Creating the New Post Lambda Function",
	"tags": [],
	"description": "",
	"content": "In this task, we will create the first Lambda function of the application. This function serves as the entry point, receiving information about new posts that need to be converted into audio files.\nSteps to Create the Lambda Function: Step 1. Navigate to the AWS Management Console and search for Lambda.\nStep 2. On the Lambda service page, select Create function.\nStep 3. Set up the function.\nChoose the option Author from scratch.\nFunction name: Enter PostReader_NewPost.\nRuntime: Select Python 3.12.\nClick on Change default execution role to expand the role options.\nExecution role: Select Use an existing role. Existing role: Choose Lab-Lambda-Role. Select Create function to complete the setup.\nStep 4. Add code to the function.\nIn the Function code section, delete any existing code.\nPaste the following Python code:\nimport boto3 import os import uuid def lambda_handler(event, context): recordId = str(uuid.uuid4()) voice = event[\u0026#34;voice\u0026#34;] text = event[\u0026#34;text\u0026#34;] print(\u0026#39;Generating new DynamoDB record, with ID: \u0026#39; + recordId) print(\u0026#39;Input Text: \u0026#39; + text) print(\u0026#39;Selected voice: \u0026#39; + voice) # Create a new record in the DynamoDB table dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(os.environ[\u0026#39;DB_TABLE_NAME\u0026#39;]) table.put_item( Item={ \u0026#39;id\u0026#39;: recordId, \u0026#39;text\u0026#39;: text, \u0026#39;voice\u0026#39;: voice, \u0026#39;status\u0026#39;: \u0026#39;PROCESSING\u0026#39; } ) # Send notification about the new post to SNS client = boto3.client(\u0026#39;sns\u0026#39;) client.publish( TopicArn=os.environ[\u0026#39;SNS_TOPIC\u0026#39;], Message=recordId ) return recordId The Lambda function performs the following tasks: Takes two input parameters:\nVoice: One of the many voices supported by Amazon Polly. Text: The content of the post that needs to be converted into an audio file. Creates a new record in the DynamoDB table with information about the new post.\nSends information about the new post to SNS.\nReturns the ID of the DynamoDB item to the user.\nStep 5. Click Deploy to save the changes.\nStep 6. Configure environment variables.\nNavigate to the Configuration tab.\nIn the left panel, select Environment variables.\nClick on Edit and add the following variables:\nKey: Enter SNS_TOPIC, Value: [Paste the ARN of the SNS topic you created earlier]. Key: Enter DB_TABLE_NAME, Value: Enter posts. Click on Save.\nStep 7. General configuration.\nIn the left panel of the Configuration tab, select General configuration.\nClick on Edit.\nUpdate Timeout to 10 seconds.\nClick on Save.\nSteps to test the Lambda function: Step 1. Create a test event.\nNavigate to the Test tab.\nConfigure a new test event with the following details:\nEvent name: Joanna Event JSON: {\r\u0026#34;voice\u0026#34;: \u0026#34;Joanna\u0026#34;,\r\u0026#34;text\u0026#34;: \u0026#34;This is working!\u0026#34;\r} Click Save. Step 2. Run the test.\nClick on Test to execute your test event.\nYou will see the message “Execution result: succeeded.”\nExpand the Details section to view the execution logs.\n"
},
{
	"uri": "//localhost:1313/4-load-balance/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "Through the workshop on Building a Serverless Text-to-Speech Application with Amazon Polly, you have experienced the process of creating a serverless application using powerful AWS services such as Amazon Polly, Lambda, API Gateway, DynamoDB, and S3. By fully deploying the application on a serverless platform, you not only save effort in managing infrastructure but also ensure flexibility, scalability, and cost optimization.\nThis application is just a small example of Text-to-Speech; we can easily integrate this feature into larger projects to enhance user experience in areas like learning and consuming content while on the go. With Amazon Polly and AWS\u0026rsquo;s serverless ecosystem, you can effortlessly scale the application and add exciting new features.\nBy the end of the workshop, you have gained a basic understanding of how to use serverless technology to build practical applications, as well as a clear understanding of the components involved in designing and deploying a serverless system.\nWorkshop References Build Your Own Text-to-Speech Applications with Amazon Polly What is Amazon Polly? What is Amazon API Gateway? What is AWS Lambda? "
},
{
	"uri": "//localhost:1313/5-clean-up/",
	"title": "Clean Up Resources",
	"tags": [],
	"description": "",
	"content": "After completing the workshop, it is important to delete the CloudFormation stack to avoid any unwanted costs. Follow these steps to clean up resources:\nStep 1 Open the AWS CloudFormation Console.\nStep 2 Select the stack you created for this workshop.\nStep 3 Click the “Delete” button .\nStep 4 In the confirmation dialog, select Delete to confirm the deletion.\nStep 5 Wait for the stack deletion process to complete. This may take a few minutes.\nOnce the stack is deleted, all related resources will be removed from your account.\nThus, the resources have been cleaned up. To avoid unnecessary waste, it is advisable to regularly check for active services on your AWS account. For any services that are no longer in use, you should delete them.\nThis concludes the workshop. Thank you very much for participating!\n"
},
{
	"uri": "//localhost:1313/3-target-group/3.7/",
	"title": "Create Lambda Function to Get Post",
	"tags": [],
	"description": "",
	"content": "In this task, we will create a function to retrieve information about existing posts in DynamoDB.\nSteps to Create the Function: Step 1. Navigate to the Lambda service page.\nStep 2. Select Create function.\nStep 3. Set up the function.\nSelect the option Author from scratch.\nFunction name: Name the function: PostReader_GetPost.\nRuntime: Choose Python 3.12.\nClick on Change default execution role to expand the default execution role options.\nExecution role: Select Use an existing role.\nExisting role: Choose Lab-Lambda-Role.\nSelect create function to complete the function creation process.\nStep 4. Add code to the function.\nDelete all existing code in the function and insert the Python code:\nimport boto3 import os from boto3.dynamodb.conditions import Key, Attr def lambda_handler(event, context): postId = event[\u0026#34;postId\u0026#34;] dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(os.environ[\u0026#39;DB_TABLE_NAME\u0026#39;]) if postId==\u0026#34;*\u0026#34;: items = table.scan() else: items = table.query( KeyConditionExpression=Key(\u0026#39;id\u0026#39;).eq(postId) ) return items[\u0026#34;Items\u0026#34;] Step 5. Select Deploy to save changes.\nSimilar to the two functions we created earlier, we will now add the name of the DynamoDB table to the environment variable for the function.\nStep 6. Configure Environment Variables\nNavigate to the \u0026ldquo;Configuration\u0026rdquo; tab.\nIn the left panel, select \u0026ldquo;Environment variables.\u0026rdquo;\nClick on \u0026ldquo;Edit\u0026rdquo; and add the following variable:\nKey: Enter: DB_TABLE_NAME, Value: Enter: posts Click on \u0026ldquo;Save.\u0026rdquo;\nStep 7. Test the Function\nSelect the \u0026ldquo;Test\u0026rdquo; tab.\nChoose Create new event.\nEvent name: Enter AllPosts.\nEvent JSON:\n{\r\u0026#34;postId\u0026#34;: \u0026#34;\\*\u0026#34;\r} Click Save and then select Test.\nA success message will be displayed. Click on Details to see the results of the test.\n"
},
{
	"uri": "//localhost:1313/3-target-group/3.8/",
	"title": "Expose Lambda Functions as RESTful Web Services",
	"tags": [],
	"description": "",
	"content": "Now that our logic processing is set up, we will use Amazon API Gateway to expose our Lambda functions as RESTful web services. This allows us to call them easily using HTTP protocols.\nCreate API Gateway Step 1. In the AWS Management Console, search for API Gateway.\nStep 2. Among the API types, we will use REST API and select Build.\nStep 3. Create REST API.\nSelect “New API.”\nAPI name: Name it: PostReaderAPI.\nDescription: API for TTS application.\nAPI endpoint type: select Regional.\nChoose Create API.\nConfigure HTTP Methods POST Method Step 1. In the Resources panel, select the root resource (/).\nStep 2. Select Create method.\nStep 3. Configure the method.\nMethod type: Select POST.\nIntegration type: Choose Lambda Function.\nSelect the function containing PostReader_NewPost.\nChoose Create method to complete the creation process.\nGET Method Step 1. In the Resources panel, select the root resource (/).\nStep 2. Select Create method.\nStep 3. Configure the method.\nMethod type: Select GET.\nIntegration type: Choose Lambda Function.\nSelect the function containing PostReader_GetPost.\nChoose Create method to complete the creation process.\nEnable CORS Cross-Origin Resource Sharing (CORS) allows API calls from different domains.\nStep 1. In the Resources panel, select the root resource (/).\nStep 2. Select Enable CORS.\nStep 3. Configure settings.\nGateway responses: Select “Default 4XX” and “Default 5XX.”\nAccess-Control-Allow-Methods: Select GET and POST.\nClick Save to finalize the configuration.\nConfigure Query Parameters Next, we will configure the GET method to accept a query parameter named postId. This parameter will provide information about the ID of the post you want to retrieve.\nStep 1. Select the GET method.\nStep 2. In the Method request section, select Edit.\nStep 3. Click on URL query string parameters to expand it.\nStep 4. Select Add query string and parameter with Name: postId.\nStep 5. Click Save.\nSet Up Request Mapping The PostReader_GetPost Lambda function requires the input data to be in JSON format, so we need to configure the API to convert the parameters sent by the user (such as postId from the query parameter) into JSON format before passing it to the Lambda function.\nStep 1. Select the GET method.\nStep 2. Go to the Integration Request tab and select Edit.\nStep 3. Adjust the settings.\nFor Request body passthrough: select “When there are no templates defined (recommended).”\nClick on Mapping Templates to expand it.\nContent-Type: Enter application/json.\nTemplate body: Enter:\n{\r\u0026#34;postId\u0026#34; : \u0026#34;$input.params(\u0026#39;postId\u0026#39;)\u0026#34;\r} Click Save to save the changes. Deploy API After all configurations, the API is ready to be deployed!\nStep 1. Select Deploy API.\nStep 2.\nStage: Select New Stage.\nStage name: Name it: Dev.\nThe description section can be skipped; select Deploy.\nStep 3. After a successful deployment, save the Invoke URL for future use.\n"
},
{
	"uri": "//localhost:1313/3-target-group/3.9/",
	"title": "Create a Serverless User Interface",
	"tags": [],
	"description": "",
	"content": "Although the application is operational, it is currently only available as a RESTful web service. To facilitate easier user interaction, we will deploy a small website hosted on Amazon S3. Amazon S3 is an ideal choice for hosting static websites because it is simple, cost-effective, and easy to manage.\nThis website will use JavaScript to connect directly with the API we have created, providing text-to-speech functionality through the web interface. This allows users to enter text directly on the website and hear the generated speech results without directly interacting with the REST API.\nSteps to Implement: Step 1. Download the following files to your machine. You can right-click and select “Save Link As…” or open the file and right-click to select “Save As…”\nindex.html\nscripts.js\nstyles.css\nKeep the names and extensions of the files unchanged for proper functionality!\nStep 2. Open the scripts.js file in any text editor (e.g., Notepad). At the first line, you will see:\nvar API\\_ENDPOINT = \u0026#34;YOUR\\_API\\_GATEWAY\\_ENDPOINT\u0026#34; Replace “YOUR_API_GATEWAY_ENDPOINT” with the Invoke URL of the API you just deployed above. Remember to save the file afterward.\nStep 3. Create an S3 bucket to store the 3 files.\nNavigate to the S3 service page.\nSelect Create bucket and configure the following details:\nBucket name: Since the name needs to be unique, we will name it: www-BUCKET, with BUCKET replaced by the name of the audioposts bucket you created earlier (e.g., my bucket name is: www-audioposts-19012003).\nRemember to note down the bucket name for future use.\nFor Object Ownership, select ACLs enabled.\nIn the Block Public Access settings for this bucket: uncheck Block all public access and ensure that all other options are also unchecked.\nA warning box will appear; check the box “I acknowledge that the current settings might result in this bucket and the objects within becoming public.”\nSelect Create bucket.\nStep 4. Upload the 3 files to the Amazon S3 bucket.\nOnce the bucket has been created, select it from the bucket list.\nSelect Upload.\nSelect Add files and upload the 3 files: index.html, scripts.js, and styles.css. Click Upload to complete the file upload.\nThe files must retain their original names: index.html, scripts.js, and styles.css.\nStep 5. Return to the bucket page containing the 3 files, switch to the Permissions tab.\nIn the Bucket Policy section, select the Edit button.\nPaste this Policy into the editor:\n{\r\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,\r\u0026#34;Statement\u0026#34;: [\r{\r\u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;,\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;,\r\u0026#34;Action\u0026#34;: [\r\u0026#34;s3:GetObject\u0026#34;\r],\r\u0026#34;Resource\u0026#34;: [\r\u0026#34;arn:aws:s3:::www-BUCKET/*\u0026#34;\r]\r}\r]\r} Replace www-BUCKET with the name of your bucket.\nClick Save changes.\nStep 6. Finally, we will enable static website hosting, so the bucket will function as a static website.\nSwitch to the Properties tab.\nFind the Static website hosting section and select Edit.\nSelect Enable for Static website hosting.\nFor Index document: enter index.html.\nFor Error document - optional: enter index.html.\nWe are using the index.html file as the error document.\nClick Save changes.\nAfter saving, go back to the Static website hosting section and copy the Bucket website endpoint.\nAnd that’s it! You can check whether the website is operational.\nOpen a web browser tab and paste the Endpoint URL you just copied.\nThe website will open:\nIf you enter something in the text box and select Say it, a new post will be sent to your application. The application will convert the text into an audio file.\nTo view the posts and their audio files, enter the post ID or * (to display all) in the search box:\nDepending on the size of the text you provide, the conversion process to audio may take some time. Posts that have not yet been converted will have a Status of PROCESSING.\nClick Play to listen to the audio.\nWebsite link: http://www-audioposts-19012003.s3-website-us-east-1.amazonaws.com/\n"
},
{
	"uri": "//localhost:1313/3-target-group/3.5/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Creating the “Convert to Audio” Lambda Function In this task, we will create a Lambda function to convert text stored in the DynamoDB table into an audio file. This is the central function of the application that defines its primary functionality.\nSteps to Create the Lambda Function Step 1. Navigate to the AWS Management Console and search for Lambda.\nStep 2. In the Lambda service page, select Create function.\nStep 3. Configure the function.\nSelect the option Author from scratch.\nFunction name: Name the function ConvertToAudio.\nRuntime: Select Python 3.12.\nClick on Change default execution role to expand the default execution role options.\nExecution role: Select Use an existing role.\nExisting role: Choose Lab-Lambda-Role.\nSelect Create function to complete the function creation process.\nStep 4. Add code to the function.\nIn the Function code section, delete the existing code.\nPaste the following Python code:\nimport boto3 import os from contextlib import closing from boto3.dynamodb.conditions import Key, Attr def lambda_handler(event, context): postId = event[\u0026#34;Records\u0026#34;][0][\u0026#34;Sns\u0026#34;][\u0026#34;Message\u0026#34;] print (\u0026#34;Text to Speech function. Post ID in DynamoDB: \u0026#34; + postId) # Retrieving information about the post from DynamoDB table dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(os.environ[\u0026#39;DB_TABLE_NAME\u0026#39;]) postItem = table.query( KeyConditionExpression=Key(\u0026#39;id\u0026#39;).eq(postId) ) text = postItem[\u0026#34;Items\u0026#34;][0][\u0026#34;text\u0026#34;] voice = postItem[\u0026#34;Items\u0026#34;][0][\u0026#34;voice\u0026#34;] rest = text # Because single invocation of the polly synthesize_speech api can # transform text with about 3000 characters, we are dividing the # post into blocks of approximately 2500 characters. textBlocks = [] while (len(rest) \u0026gt; 2600): begin = 0 end = rest.find(\u0026#34;.\u0026#34;, 2500) if (end == -1): end = rest.find(\u0026#34; \u0026#34;, 2500) textBlock = rest[begin:end] rest = rest[end:] textBlocks.append(textBlock) textBlocks.append(rest) # For each block, invoke Polly API, which transforms text into audio polly = boto3.client(\u0026#39;polly\u0026#39;) for textBlock in textBlocks: response = polly.synthesize_speech( OutputFormat=\u0026#39;mp3\u0026#39;, Text = textBlock, VoiceId = voice ) # Save the audio stream returned by Amazon Polly on Lambda\u0026#39;s temp # directory. If there are multiple text blocks, the audio stream # is combined into a single file. if \u0026#34;AudioStream\u0026#34; in response: with closing(response[\u0026#34;AudioStream\u0026#34;]) as stream: output = os.path.join(\u0026#34;/tmp/\u0026#34;, postId) if os.path.isfile(output): mode = \u0026#34;ab\u0026#34; # Append binary mode else: mode = \u0026#34;wb\u0026#34; # Write binary mode (create a new file) with open(output, mode) as file: file.write(stream.read()) s3 = boto3.client(\u0026#39;s3\u0026#39;) s3.upload_file(\u0026#39;/tmp/\u0026#39; + postId, os.environ[\u0026#39;BUCKET_NAME\u0026#39;], postId + \u0026#34;.mp3\u0026#34;) s3.put_object_acl(ACL=\u0026#39;public-read\u0026#39;, Bucket=os.environ[\u0026#39;BUCKET_NAME\u0026#39;], Key= postId + \u0026#34;.mp3\u0026#34;) location = s3.get_bucket_location(Bucket=os.environ[\u0026#39;BUCKET_NAME\u0026#39;]) region = location[\u0026#39;LocationConstraint\u0026#39;] if region is None: url_beginning = \u0026#34;https://s3.amazonaws.com/\u0026#34; else: url_beginning = \u0026#34;https://s3-\u0026#34; + str(region) + \u0026#34;.amazonaws.com/\u0026#34; url = url_beginning \\ + str(os.environ[\u0026#39;BUCKET_NAME\u0026#39;]) \\ + \u0026#34;/\u0026#34; \\ + str(postId) \\ + \u0026#34;.mp3\u0026#34; # Updating the item in DynamoDB response = table.update_item( Key={\u0026#39;id\u0026#39;:postId}, UpdateExpression= \u0026#34;SET #statusAtt = :statusValue, #urlAtt = :urlValue\u0026#34;, ExpressionAttributeValues= {\u0026#39;:statusValue\u0026#39;: \u0026#39;UPDATED\u0026#39;, \u0026#39;:urlValue\u0026#39;: url}, ExpressionAttributeNames= {\u0026#39;#statusAtt\u0026#39;: \u0026#39;status\u0026#39;, \u0026#39;#urlAtt\u0026#39;: \u0026#39;url\u0026#39;}, ) return Lambda Function Responsibilities The Lambda function performs the following tasks:\nRetrieves the text content from DynamoDB based on the provided post ID. Splits the text into smaller segments (if necessary). Uses Amazon Polly to convert each text segment into speech. Saves the resulting audio files to an S3 bucket. Splitting the text into segments before converting it to audio and then concatenating the audio segments helps avoid Polly\u0026rsquo;s input limit of 3,000 characters. This makes the application run smoothly and efficiently.\nStep 5. Click Deploy to save the changes.\nStep 6. Configure environment variables.\nNavigate to the Configuration tab.\nIn the left-hand panel, select Environment variables.\nClick Edit and add the following variables:\nKey: Enter: DB_TABLE_NAME, Value: Enter: posts Key: Enter: BUCKET_NAME, Value: Enter: audioposts-19012003 (the name of the bucket you created earlier). Click Save.\nStep 7. General configuration.\nIn the left-hand panel of the Configuration tab, select General configuration.\nClick Edit.\nUpdate the Timeout to 5 minutes.\nClick Save.\nStep 8. Set up the function to trigger automatically when a message is sent to the SNS topic created earlier.\nIn the left-hand panel of the Configuration tab, select Triggers.\nClick Add trigger.\nChoose the source as SNS.\nSNS topics: Select new_posts from the available topics.\nClick Add.\nNow we have created two Lambda functions. Next, we can test whether the two Lambda functions communicate successfully through SNS.\n"
},
{
	"uri": "//localhost:1313/3-target-group/3.6/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Testing the Functions In this task, we will test whether the two created Lambda functions are working correctly. The operational workflow includes:\nManually triggering the New Post Lambda function. Data is added to DynamoDB and a message is sent to the SNS topic. SNS triggers the Convert to Audio function. The Convert to Audio function uses Amazon Polly to create an audio file. The audio file is saved in an S3 bucket. Perform the Test: 1. Manually Trigger the New Post Lambda Function Step 1. Navigate to the AWS Lambda service page.\nStep 2. In the left menu, select Functions.\nSelect the function PostReader_NewPost.\nStep 3. Switch to the Test tab and then click Test.\nA message will appear when the function executes successfully.\n2. Check if Data Was Added to DynamoDB Step 1. Navigate to the AWS DynamoDB service page.\nStep 2. In the left menu, select Explore items.\nStep 3. Select the table posts.\nDepending on how many times you have tested the New Post function, the number of items in the posts table will vary.\n3. Check the Activity of the Convert to Audio Function Step 1. Navigate to the AWS Lambda service page.\nStep 2. In the left menu, select Functions and choose the function ConvertToAudio.\nStep 3. Click on the Monitor tab.\nYou can view the monitoring charts for the function calls. In the Recent invocations section, you should see two recent calls corresponding to your New Post function tests after creating the ConvertToAudio function.\n4. Check if Audio Files Have Been Created in S3 Step 1. Navigate to the AWS S3 service page.\nStep 2. Find and select the bucket audioposts-19012003 (the name of the bucket you created).\nStep 3. In the Objects tab, you will see the created audio files. You can select a file, download it, and listen to Polly\u0026rsquo;s voice saying “This is working!”\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]